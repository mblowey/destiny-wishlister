// <auto-generated />
// Command: quicktype https://destiny.plumbing/en/raw/DestinyInventoryItemDefinition.json -o InventoryItem.cs --array-type list --namespace JsonDataCreator
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using JsonDataCreator;
//
//    var inventoryItem = InventoryItem.FromJson(jsonString);

namespace JsonDataCreator
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class InventoryItem
    {
        [JsonProperty("displayProperties")]
        public DisplayProperties DisplayProperties { get; set; }

        [JsonProperty("collectibleHash", NullValueHandling = NullValueHandling.Ignore)]
        public long? CollectibleHash { get; set; }

        [JsonProperty("backgroundColor", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundColor BackgroundColor { get; set; }

        [JsonProperty("screenshot", NullValueHandling = NullValueHandling.Ignore)]
        public string Screenshot { get; set; }

        [JsonProperty("itemTypeDisplayName", NullValueHandling = NullValueHandling.Ignore)]
        public string ItemTypeDisplayName { get; set; }

        [JsonProperty("uiItemDisplayStyle", NullValueHandling = NullValueHandling.Ignore)]
        public UiItemDisplayStyle? UiItemDisplayStyle { get; set; }

        [JsonProperty("itemTypeAndTierDisplayName", NullValueHandling = NullValueHandling.Ignore)]
        public string ItemTypeAndTierDisplayName { get; set; }

        [JsonProperty("displaySource", NullValueHandling = NullValueHandling.Ignore)]
        public string DisplaySource { get; set; }

        [JsonProperty("action", NullValueHandling = NullValueHandling.Ignore)]
        public Action Action { get; set; }

        [JsonProperty("inventory")]
        public Inventory Inventory { get; set; }

        [JsonProperty("stats", NullValueHandling = NullValueHandling.Ignore)]
        public Stats Stats { get; set; }

        [JsonProperty("equippingBlock", NullValueHandling = NullValueHandling.Ignore)]
        public EquippingBlock EquippingBlock { get; set; }

        [JsonProperty("translationBlock", NullValueHandling = NullValueHandling.Ignore)]
        public TranslationBlock TranslationBlock { get; set; }

        [JsonProperty("preview", NullValueHandling = NullValueHandling.Ignore)]
        public Preview Preview { get; set; }

        [JsonProperty("quality", NullValueHandling = NullValueHandling.Ignore)]
        public Quality Quality { get; set; }

        [JsonProperty("sourceData", NullValueHandling = NullValueHandling.Ignore)]
        public SourceData SourceData { get; set; }

        [JsonProperty("acquireRewardSiteHash")]
        public long AcquireRewardSiteHash { get; set; }

        [JsonProperty("acquireUnlockHash")]
        public long AcquireUnlockHash { get; set; }

        [JsonProperty("sockets", NullValueHandling = NullValueHandling.Ignore)]
        public Sockets Sockets { get; set; }

        [JsonProperty("talentGrid", NullValueHandling = NullValueHandling.Ignore)]
        public TalentGrid TalentGrid { get; set; }

        [JsonProperty("investmentStats", NullValueHandling = NullValueHandling.Ignore)]
        public List<InvestmentStat> InvestmentStats { get; set; }

        [JsonProperty("perks", NullValueHandling = NullValueHandling.Ignore)]
        public List<Perk> Perks { get; set; }

        [JsonProperty("summaryItemHash", NullValueHandling = NullValueHandling.Ignore)]
        public long? SummaryItemHash { get; set; }

        [JsonProperty("allowActions")]
        public bool AllowActions { get; set; }

        [JsonProperty("doesPostmasterPullHaveSideEffects")]
        public bool DoesPostmasterPullHaveSideEffects { get; set; }

        [JsonProperty("nonTransferrable")]
        public bool NonTransferrable { get; set; }

        [JsonProperty("itemCategoryHashes", NullValueHandling = NullValueHandling.Ignore)]
        public List<long> ItemCategoryHashes { get; set; }

        [JsonProperty("specialItemType")]
        public long SpecialItemType { get; set; }

        [JsonProperty("itemType")]
        public long ItemType { get; set; }

        [JsonProperty("itemSubType")]
        public long ItemSubType { get; set; }

        [JsonProperty("classType")]
        public long ClassType { get; set; }

        [JsonProperty("equippable")]
        public bool Equippable { get; set; }

        [JsonProperty("defaultDamageType")]
        public long DefaultDamageType { get; set; }

        [JsonProperty("hash")]
        public long Hash { get; set; }

        [JsonProperty("index")]
        public long Index { get; set; }

        [JsonProperty("redacted")]
        public bool Redacted { get; set; }

        [JsonProperty("blacklisted")]
        public bool Blacklisted { get; set; }

        [JsonProperty("secondaryIcon", NullValueHandling = NullValueHandling.Ignore)]
        public string SecondaryIcon { get; set; }

        [JsonProperty("secondaryOverlay", NullValueHandling = NullValueHandling.Ignore)]
        public string SecondaryOverlay { get; set; }

        [JsonProperty("secondarySpecial", NullValueHandling = NullValueHandling.Ignore)]
        public string SecondarySpecial { get; set; }

        [JsonProperty("tooltipStyle", NullValueHandling = NullValueHandling.Ignore)]
        public TooltipStyle? TooltipStyle { get; set; }

        [JsonProperty("objectives", NullValueHandling = NullValueHandling.Ignore)]
        public Objectives Objectives { get; set; }

        [JsonProperty("damageTypeHashes", NullValueHandling = NullValueHandling.Ignore)]
        public List<long> DamageTypeHashes { get; set; }

        [JsonProperty("damageTypes", NullValueHandling = NullValueHandling.Ignore)]
        public List<long> DamageTypes { get; set; }

        [JsonProperty("defaultDamageTypeHash", NullValueHandling = NullValueHandling.Ignore)]
        public long? DefaultDamageTypeHash { get; set; }

        [JsonProperty("gearset", NullValueHandling = NullValueHandling.Ignore)]
        public Gearset Gearset { get; set; }

        [JsonProperty("plug", NullValueHandling = NullValueHandling.Ignore)]
        public Plug Plug { get; set; }

        [JsonProperty("emblemObjectiveHash", NullValueHandling = NullValueHandling.Ignore)]
        public long? EmblemObjectiveHash { get; set; }

        [JsonProperty("sack", NullValueHandling = NullValueHandling.Ignore)]
        public Sack Sack { get; set; }

        [JsonProperty("setData", NullValueHandling = NullValueHandling.Ignore)]
        public SetData SetData { get; set; }

        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public Value Value { get; set; }

        [JsonProperty("loreHash", NullValueHandling = NullValueHandling.Ignore)]
        public long? LoreHash { get; set; }

        [JsonProperty("summary", NullValueHandling = NullValueHandling.Ignore)]
        public Summary Summary { get; set; }

        [JsonProperty("animations", NullValueHandling = NullValueHandling.Ignore)]
        public List<object> Animations { get; set; }

        [JsonProperty("links", NullValueHandling = NullValueHandling.Ignore)]
        public List<object> Links { get; set; }
    }

    public partial class Action
    {
        [JsonProperty("verbName")]
        public VerbName VerbName { get; set; }

        [JsonProperty("verbDescription")]
        public VerbDescription VerbDescription { get; set; }

        [JsonProperty("isPositive")]
        public bool IsPositive { get; set; }

        [JsonProperty("requiredCooldownSeconds")]
        public long RequiredCooldownSeconds { get; set; }

        [JsonProperty("requiredItems")]
        public List<RequiredItem> RequiredItems { get; set; }

        [JsonProperty("progressionRewards")]
        public List<ProgressionReward> ProgressionRewards { get; set; }

        [JsonProperty("actionTypeLabel", NullValueHandling = NullValueHandling.Ignore)]
        public ActionTypeLabel? ActionTypeLabel { get; set; }

        [JsonProperty("rewardSheetHash")]
        public long RewardSheetHash { get; set; }

        [JsonProperty("rewardItemHash")]
        public long RewardItemHash { get; set; }

        [JsonProperty("rewardSiteHash")]
        public long RewardSiteHash { get; set; }

        [JsonProperty("requiredCooldownHash")]
        public long RequiredCooldownHash { get; set; }

        [JsonProperty("deleteOnAction")]
        public bool DeleteOnAction { get; set; }

        [JsonProperty("consumeEntireStack")]
        public bool ConsumeEntireStack { get; set; }

        [JsonProperty("useOnAcquire")]
        public bool UseOnAcquire { get; set; }
    }

    public partial class ProgressionReward
    {
        [JsonProperty("progressionMappingHash")]
        public long ProgressionMappingHash { get; set; }

        [JsonProperty("amount")]
        public long Amount { get; set; }

        [JsonProperty("applyThrottles")]
        public bool ApplyThrottles { get; set; }
    }

    public partial class RequiredItem
    {
        [JsonProperty("count")]
        public long Count { get; set; }

        [JsonProperty("itemHash")]
        public long ItemHash { get; set; }

        [JsonProperty("deleteOnAction")]
        public bool DeleteOnAction { get; set; }
    }

    public partial class BackgroundColor
    {
        [JsonProperty("colorHash")]
        public long ColorHash { get; set; }

        [JsonProperty("red")]
        public long Red { get; set; }

        [JsonProperty("green")]
        public long Green { get; set; }

        [JsonProperty("blue")]
        public long Blue { get; set; }

        [JsonProperty("alpha")]
        public long Alpha { get; set; }
    }

    public partial class DisplayProperties
    {
        [JsonProperty("description")]
        public string Description { get; set; }

        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("icon", NullValueHandling = NullValueHandling.Ignore)]
        public string Icon { get; set; }

        [JsonProperty("hasIcon")]
        public bool HasIcon { get; set; }
    }

    public partial class EquippingBlock
    {
        [JsonProperty("uniqueLabelHash")]
        public long UniqueLabelHash { get; set; }

        [JsonProperty("equipmentSlotTypeHash")]
        public long EquipmentSlotTypeHash { get; set; }

        [JsonProperty("attributes")]
        public long Attributes { get; set; }

        [JsonProperty("equippingSoundHash")]
        public long EquippingSoundHash { get; set; }

        [JsonProperty("hornSoundHash")]
        public long HornSoundHash { get; set; }

        [JsonProperty("ammoType")]
        public long AmmoType { get; set; }

        [JsonProperty("displayStrings")]
        public List<DisplayString> DisplayStrings { get; set; }

        [JsonProperty("uniqueLabel", NullValueHandling = NullValueHandling.Ignore)]
        public string UniqueLabel { get; set; }
    }

    public partial class Gearset
    {
        [JsonProperty("trackingValueMax")]
        public long TrackingValueMax { get; set; }

        [JsonProperty("itemList")]
        public List<long> ItemList { get; set; }
    }

    public partial class Inventory
    {
        [JsonProperty("maxStackSize")]
        public long MaxStackSize { get; set; }

        [JsonProperty("bucketTypeHash")]
        public long BucketTypeHash { get; set; }

        [JsonProperty("recoveryBucketTypeHash")]
        public long RecoveryBucketTypeHash { get; set; }

        [JsonProperty("tierTypeHash")]
        public long TierTypeHash { get; set; }

        [JsonProperty("isInstanceItem")]
        public bool IsInstanceItem { get; set; }

        [JsonProperty("nonTransferrableOriginal")]
        public bool NonTransferrableOriginal { get; set; }

        [JsonProperty("tierTypeName", NullValueHandling = NullValueHandling.Ignore)]
        public TierTypeName? TierTypeName { get; set; }

        [JsonProperty("tierType")]
        public long TierType { get; set; }

        [JsonProperty("expirationTooltip", NullValueHandling = NullValueHandling.Ignore)]
        public ExpirationTooltip? ExpirationTooltip { get; set; }

        [JsonProperty("expiredInActivityMessage", NullValueHandling = NullValueHandling.Ignore)]
        public string ExpiredInActivityMessage { get; set; }

        [JsonProperty("expiredInOrbitMessage", NullValueHandling = NullValueHandling.Ignore)]
        public ExpiredInOrbitMessage? ExpiredInOrbitMessage { get; set; }

        [JsonProperty("suppressExpirationWhenObjectivesComplete")]
        public bool SuppressExpirationWhenObjectivesComplete { get; set; }

        [JsonProperty("stackUniqueLabel", NullValueHandling = NullValueHandling.Ignore)]
        public string StackUniqueLabel { get; set; }
    }

    public partial class InvestmentStat
    {
        [JsonProperty("statTypeHash")]
        public long StatTypeHash { get; set; }

        [JsonProperty("value")]
        public long Value { get; set; }

        [JsonProperty("isConditionallyActive")]
        public bool IsConditionallyActive { get; set; }
    }

    public partial class Objectives
    {
        [JsonProperty("objectiveHashes")]
        public List<long> ObjectiveHashes { get; set; }

        [JsonProperty("displayActivityHashes")]
        public List<long> DisplayActivityHashes { get; set; }

        [JsonProperty("requireFullObjectiveCompletion")]
        public bool RequireFullObjectiveCompletion { get; set; }

        [JsonProperty("questlineItemHash")]
        public long QuestlineItemHash { get; set; }

        [JsonProperty("narrative")]
        public string Narrative { get; set; }

        [JsonProperty("objectiveVerbName")]
        public ObjectiveVerbName ObjectiveVerbName { get; set; }

        [JsonProperty("questTypeIdentifier")]
        public QuestTypeIdentifier QuestTypeIdentifier { get; set; }

        [JsonProperty("questTypeHash")]
        public long QuestTypeHash { get; set; }

        [JsonProperty("completionRewardSiteHash")]
        public long CompletionRewardSiteHash { get; set; }

        [JsonProperty("nextQuestStepRewardSiteHash")]
        public long NextQuestStepRewardSiteHash { get; set; }

        [JsonProperty("timestampUnlockValueHash")]
        public long TimestampUnlockValueHash { get; set; }

        [JsonProperty("isGlobalObjectiveItem")]
        public bool IsGlobalObjectiveItem { get; set; }

        [JsonProperty("useOnObjectiveCompletion")]
        public bool UseOnObjectiveCompletion { get; set; }

        [JsonProperty("inhibitCompletionUnlockValueHash")]
        public long InhibitCompletionUnlockValueHash { get; set; }

        [JsonProperty("perObjectiveDisplayProperties")]
        public List<PerObjectiveDisplayProperty> PerObjectiveDisplayProperties { get; set; }
    }

    public partial class PerObjectiveDisplayProperty
    {
        [JsonProperty("displayOnItemPreviewScreen")]
        public bool DisplayOnItemPreviewScreen { get; set; }

        [JsonProperty("activityHash", NullValueHandling = NullValueHandling.Ignore)]
        public long? ActivityHash { get; set; }
    }

    public partial class Perk
    {
        [JsonProperty("requirementDisplayString")]
        public string RequirementDisplayString { get; set; }

        [JsonProperty("perkHash")]
        public long PerkHash { get; set; }

        [JsonProperty("perkVisibility")]
        public long PerkVisibility { get; set; }
    }

    public partial class Plug
    {
        [JsonProperty("insertionRules")]
        public List<Rule> InsertionRules { get; set; }

        [JsonProperty("plugCategoryIdentifier")]
        public string PlugCategoryIdentifier { get; set; }

        [JsonProperty("plugCategoryHash")]
        public long PlugCategoryHash { get; set; }

        [JsonProperty("onActionRecreateSelf")]
        public bool OnActionRecreateSelf { get; set; }

        [JsonProperty("actionRewardSiteHash")]
        public long ActionRewardSiteHash { get; set; }

        [JsonProperty("actionRewardItemOverrideHash")]
        public long ActionRewardItemOverrideHash { get; set; }

        [JsonProperty("insertionMaterialRequirementHash")]
        public long InsertionMaterialRequirementHash { get; set; }

        [JsonProperty("previewItemOverrideHash")]
        public long PreviewItemOverrideHash { get; set; }

        [JsonProperty("enabledMaterialRequirementHash")]
        public long EnabledMaterialRequirementHash { get; set; }

        [JsonProperty("enabledRules")]
        public List<Rule> EnabledRules { get; set; }

        [JsonProperty("uiPlugLabel")]
        public UiPlugLabel UiPlugLabel { get; set; }

        [JsonProperty("plugStyle")]
        public long PlugStyle { get; set; }

        [JsonProperty("isPseudoPlug")]
        public bool IsPseudoPlug { get; set; }

        [JsonProperty("plugAvailability")]
        public long PlugAvailability { get; set; }

        [JsonProperty("alternateUiPlugLabel")]
        public string AlternateUiPlugLabel { get; set; }

        [JsonProperty("alternatePlugStyle")]
        public long AlternatePlugStyle { get; set; }

        [JsonProperty("isDummyPlug")]
        public bool IsDummyPlug { get; set; }
    }

    public partial class Rule
    {
        [JsonProperty("failureMessage")]
        public string FailureMessage { get; set; }
    }

    public partial class Preview
    {
        [JsonProperty("screenStyle")]
        public ScreenStyle ScreenStyle { get; set; }

        [JsonProperty("previewVendorHash")]
        public long PreviewVendorHash { get; set; }

        [JsonProperty("previewActionString")]
        public PreviewActionString PreviewActionString { get; set; }

        [JsonProperty("derivedItemCategories", NullValueHandling = NullValueHandling.Ignore)]
        public List<DerivedItemCategory> DerivedItemCategories { get; set; }
    }

    public partial class DerivedItemCategory
    {
        [JsonProperty("categoryDescription")]
        public string CategoryDescription { get; set; }

        [JsonProperty("items")]
        public List<Item> Items { get; set; }

        [JsonProperty("categoryIndex")]
        public long CategoryIndex { get; set; }
    }

    public partial class Item
    {
        [JsonProperty("itemHash")]
        public long ItemHash { get; set; }

        [JsonProperty("vendorItemIndex")]
        public long VendorItemIndex { get; set; }
    }

    public partial class Quality
    {
        [JsonProperty("itemLevels")]
        public List<object> ItemLevels { get; set; }

        [JsonProperty("qualityLevel")]
        public long QualityLevel { get; set; }

        [JsonProperty("infusionCategoryName")]
        public string InfusionCategoryName { get; set; }

        [JsonProperty("infusionCategoryHash")]
        public long InfusionCategoryHash { get; set; }

        [JsonProperty("infusionCategoryHashes")]
        public List<long> InfusionCategoryHashes { get; set; }

        [JsonProperty("progressionLevelRequirementHash")]
        public long ProgressionLevelRequirementHash { get; set; }
    }

    public partial class Sack
    {
        [JsonProperty("detailAction")]
        public PreviewActionString DetailAction { get; set; }

        [JsonProperty("openAction")]
        public OpenAction OpenAction { get; set; }

        [JsonProperty("seedUnlockValueHash")]
        public long SeedUnlockValueHash { get; set; }

        [JsonProperty("resolvedBitVectorUnlockValueHash")]
        public long ResolvedBitVectorUnlockValueHash { get; set; }

        [JsonProperty("resolvedItemCountUnlockValueHash")]
        public long ResolvedItemCountUnlockValueHash { get; set; }

        [JsonProperty("selectItemCount")]
        public long SelectItemCount { get; set; }

        [JsonProperty("rollStateUnlockValueHash")]
        public long RollStateUnlockValueHash { get; set; }

        [JsonProperty("rewardItemListHash")]
        public long RewardItemListHash { get; set; }

        [JsonProperty("vendorSackType", NullValueHandling = NullValueHandling.Ignore)]
        public string VendorSackType { get; set; }

        [JsonProperty("openOnAcquire")]
        public bool OpenOnAcquire { get; set; }
    }

    public partial class SetData
    {
        [JsonProperty("itemList")]
        public List<ItemList> ItemList { get; set; }

        [JsonProperty("trackingUnlockValueHash")]
        public long TrackingUnlockValueHash { get; set; }

        [JsonProperty("abandonmentUnlockHash")]
        public long AbandonmentUnlockHash { get; set; }

        [JsonProperty("requireOrderedSetItemAdd")]
        public bool RequireOrderedSetItemAdd { get; set; }

        [JsonProperty("setIsFeatured")]
        public bool SetIsFeatured { get; set; }

        [JsonProperty("setType")]
        public QuestTypeIdentifier SetType { get; set; }
    }

    public partial class ItemList
    {
        [JsonProperty("trackingValue")]
        public long TrackingValue { get; set; }

        [JsonProperty("itemHash")]
        public long ItemHash { get; set; }
    }

    public partial class Sockets
    {
        [JsonProperty("detail")]
        public Detail Detail { get; set; }

        [JsonProperty("socketEntries")]
        public List<SocketEntry> SocketEntries { get; set; }

        [JsonProperty("intrinsicSockets")]
        public List<IntrinsicSocket> IntrinsicSockets { get; set; }

        [JsonProperty("socketCategories")]
        public List<SocketCategory> SocketCategories { get; set; }
    }

    public partial class IntrinsicSocket
    {
        [JsonProperty("plugItemHash")]
        public long PlugItemHash { get; set; }

        [JsonProperty("socketTypeHash")]
        public long SocketTypeHash { get; set; }

        [JsonProperty("defaultVisible")]
        public bool DefaultVisible { get; set; }
    }

    public partial class SocketCategory
    {
        [JsonProperty("socketCategoryHash")]
        public long SocketCategoryHash { get; set; }

        [JsonProperty("socketIndexes")]
        public List<long> SocketIndexes { get; set; }
    }

    public partial class SocketEntry
    {
        [JsonProperty("socketTypeHash")]
        public long SocketTypeHash { get; set; }

        [JsonProperty("singleInitialItemHash")]
        public long SingleInitialItemHash { get; set; }

        [JsonProperty("reusablePlugItems")]
        public List<ReusablePlugItem> ReusablePlugItems { get; set; }

        [JsonProperty("preventInitializationOnVendorPurchase")]
        public bool PreventInitializationOnVendorPurchase { get; set; }

        [JsonProperty("preventInitializationWhenVersioning")]
        public bool PreventInitializationWhenVersioning { get; set; }

        [JsonProperty("hidePerksInItemTooltip")]
        public bool HidePerksInItemTooltip { get; set; }

        [JsonProperty("plugSources")]
        public long PlugSources { get; set; }

        [JsonProperty("randomizedPlugItems")]
        public List<RandomizedPlugItem> RandomizedPlugItems { get; set; }

        [JsonProperty("overridesUiAppearance")]
        public bool OverridesUiAppearance { get; set; }

        [JsonProperty("defaultVisible")]
        public bool DefaultVisible { get; set; }

        [JsonProperty("reusablePlugSetHash", NullValueHandling = NullValueHandling.Ignore)]
        public long? ReusablePlugSetHash { get; set; }
    }

    public partial class RandomizedPlugItem
    {
        [JsonProperty("weight")]
        public long Weight { get; set; }

        [JsonProperty("alternateWeight")]
        public long AlternateWeight { get; set; }

        [JsonProperty("plugItemHash")]
        public long PlugItemHash { get; set; }
    }

    public partial class ReusablePlugItem
    {
        [JsonProperty("plugItemHash")]
        public long PlugItemHash { get; set; }
    }

    public partial class SourceData
    {
        [JsonProperty("sourceHashes", NullValueHandling = NullValueHandling.Ignore)]
        public List<object> SourceHashes { get; set; }

        [JsonProperty("sources", NullValueHandling = NullValueHandling.Ignore)]
        public List<Source> Sources { get; set; }

        [JsonProperty("exclusive")]
        public long Exclusive { get; set; }

        [JsonProperty("vendorSources")]
        public List<VendorSource> VendorSources { get; set; }
    }

    public partial class Source
    {
        [JsonProperty("level")]
        public long Level { get; set; }

        [JsonProperty("minQuality")]
        public long MinQuality { get; set; }

        [JsonProperty("maxQuality")]
        public long MaxQuality { get; set; }

        [JsonProperty("minLevelRequired")]
        public long MinLevelRequired { get; set; }

        [JsonProperty("maxLevelRequired")]
        public long MaxLevelRequired { get; set; }

        [JsonProperty("exclusivity")]
        public long Exclusivity { get; set; }

        [JsonProperty("computedStats")]
        public Dictionary<string, Stat> ComputedStats { get; set; }

        [JsonProperty("sourceHashes")]
        public List<object> SourceHashes { get; set; }
    }

    public partial class Stat
    {
        [JsonProperty("statHash")]
        public long StatHash { get; set; }

        [JsonProperty("value")]
        public long Value { get; set; }

        [JsonProperty("minimum")]
        public long Minimum { get; set; }

        [JsonProperty("maximum")]
        public long Maximum { get; set; }
    }

    public partial class VendorSource
    {
        [JsonProperty("vendorHash")]
        public long VendorHash { get; set; }

        [JsonProperty("vendorItemIndexes")]
        public List<long> VendorItemIndexes { get; set; }
    }

    public partial class Stats
    {
        [JsonProperty("disablePrimaryStatDisplay")]
        public bool DisablePrimaryStatDisplay { get; set; }

        [JsonProperty("statGroupHash", NullValueHandling = NullValueHandling.Ignore)]
        public long? StatGroupHash { get; set; }

        [JsonProperty("stats")]
        public Dictionary<string, Stat> StatsStats { get; set; }

        [JsonProperty("hasDisplayableStats")]
        public bool HasDisplayableStats { get; set; }

        [JsonProperty("primaryBaseStatHash")]
        public long PrimaryBaseStatHash { get; set; }
    }

    public partial class Summary
    {
        [JsonProperty("sortPriority")]
        public long SortPriority { get; set; }
    }

    public partial class TalentGrid
    {
        [JsonProperty("talentGridHash")]
        public long TalentGridHash { get; set; }

        [JsonProperty("itemDetailString")]
        public PreviewActionString ItemDetailString { get; set; }

        [JsonProperty("hudDamageType")]
        public long HudDamageType { get; set; }

        [JsonProperty("buildName", NullValueHandling = NullValueHandling.Ignore)]
        public string BuildName { get; set; }

        [JsonProperty("hudIcon", NullValueHandling = NullValueHandling.Ignore)]
        public string HudIcon { get; set; }
    }

    public partial class TranslationBlock
    {
        [JsonProperty("weaponPatternHash")]
        public long WeaponPatternHash { get; set; }

        [JsonProperty("defaultDyes")]
        public List<Dye> DefaultDyes { get; set; }

        [JsonProperty("lockedDyes")]
        public List<Dye> LockedDyes { get; set; }

        [JsonProperty("customDyes")]
        public List<Dye> CustomDyes { get; set; }

        [JsonProperty("arrangements")]
        public List<Arrangement> Arrangements { get; set; }

        [JsonProperty("hasGeometry")]
        public bool HasGeometry { get; set; }
    }

    public partial class Arrangement
    {
        [JsonProperty("classHash")]
        public long ClassHash { get; set; }

        [JsonProperty("artArrangementHash")]
        public long ArtArrangementHash { get; set; }
    }

    public partial class Dye
    {
        [JsonProperty("channelHash")]
        public long ChannelHash { get; set; }

        [JsonProperty("dyeHash")]
        public long DyeHash { get; set; }
    }

    public partial class Value
    {
        [JsonProperty("itemValue")]
        public List<ItemValue> ItemValue { get; set; }

        [JsonProperty("valueDescription")]
        public string ValueDescription { get; set; }
    }

    public partial class ItemValue
    {
        [JsonProperty("itemHash")]
        public long ItemHash { get; set; }

        [JsonProperty("quantity")]
        public long Quantity { get; set; }
    }

    public enum ActionTypeLabel { Consume, Shard, Use };

    public enum VerbDescription { Combine, Empty };

    public enum VerbName { Abandon, Archive, Combine, Consume, Crumble, Delete, Destroy, Discard, Dismantle, InsertKey, Scrap, Store, Stow, Unlock, Use };

    public enum DisplayString { CurseOfOsiris, Empty, ExclusiveItem, PreorderExclusive, RequiresAnnualPass, Warmind };

    public enum ExpirationTooltip { Empty, ExpiresIn };

    public enum ExpiredInOrbitMessage { Empty, ExpiredBountyWillBeRemovedUponLeavingOrbit };

    public enum TierTypeName { Basic, Common, Exotic, Legendary, Rare, Uncommon };

    public enum ObjectiveVerbName { ClaimBounty, ClaimTriumph, Complete, Empty };

    public enum QuestTypeIdentifier { BlackArmoryRun, Challenge, Empty, Patrol, PatrolTier1, PatrolTier2, QuestGlobal, QuestPvp, QuestStory, QuestWorld, TreasureMap };

    public enum UiPlugLabel { Empty, Masterwork, MasterworkInteractable };

    public enum PreviewActionString { Access, Configure, Details, Empty, Gauntlets, Preview };

    public enum ScreenStyle { ScreenStyleEmote, ScreenStyleMtxDirectPurchase, ScreenStylePrismaticNexus, ScreenStyleSockets, ScreenStyleSpecializations, ScreenStyleVendor };

    public enum OpenAction { Decrypt, Empty, Open, Use };

    public enum Detail { Details, Emotes, Empty, EvaSHolidayOven, FiveOfSwords, NightfallChallenge, RevelerSTonic, Shader, WeakSynthesizer };

    public enum TooltipStyle { Bounty, Build, Emblem, Package, Quest, Record, VendorAction };

    public enum UiItemDisplayStyle { Empty, UiDisplayStyleBox, UiDisplayStyleEngram, UiDisplayStyleInfuse, UiDisplayStyleIntrinsicPlug, UiDisplayStyleNexus, UiDisplayStyleRecord, UiDisplayStyleSetContainer, UiDisplayStyleSilverEngram, UiDisplayStyleToken };

    public partial class InventoryItem
    {
        public static Dictionary<string, InventoryItem> FromJson(string json) => JsonConvert.DeserializeObject<Dictionary<string, InventoryItem>>(json, JsonDataCreator.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Dictionary<string, InventoryItem> self) => JsonConvert.SerializeObject(self, JsonDataCreator.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ActionTypeLabelConverter.Singleton,
                VerbDescriptionConverter.Singleton,
                VerbNameConverter.Singleton,
                DisplayStringConverter.Singleton,
                ExpirationTooltipConverter.Singleton,
                ExpiredInOrbitMessageConverter.Singleton,
                TierTypeNameConverter.Singleton,
                ObjectiveVerbNameConverter.Singleton,
                QuestTypeIdentifierConverter.Singleton,
                UiPlugLabelConverter.Singleton,
                PreviewActionStringConverter.Singleton,
                ScreenStyleConverter.Singleton,
                OpenActionConverter.Singleton,
                DetailConverter.Singleton,
                TooltipStyleConverter.Singleton,
                UiItemDisplayStyleConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ActionTypeLabelConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ActionTypeLabel) || t == typeof(ActionTypeLabel?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "consume":
                    return ActionTypeLabel.Consume;
                case "shard":
                    return ActionTypeLabel.Shard;
                case "use":
                    return ActionTypeLabel.Use;
            }
            throw new Exception("Cannot unmarshal type ActionTypeLabel");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ActionTypeLabel)untypedValue;
            switch (value)
            {
                case ActionTypeLabel.Consume:
                    serializer.Serialize(writer, "consume");
                    return;
                case ActionTypeLabel.Shard:
                    serializer.Serialize(writer, "shard");
                    return;
                case ActionTypeLabel.Use:
                    serializer.Serialize(writer, "use");
                    return;
            }
            throw new Exception("Cannot marshal type ActionTypeLabel");
        }

        public static readonly ActionTypeLabelConverter Singleton = new ActionTypeLabelConverter();
    }

    internal class VerbDescriptionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(VerbDescription) || t == typeof(VerbDescription?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return VerbDescription.Empty;
                case "Combine":
                    return VerbDescription.Combine;
            }
            throw new Exception("Cannot unmarshal type VerbDescription");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (VerbDescription)untypedValue;
            switch (value)
            {
                case VerbDescription.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case VerbDescription.Combine:
                    serializer.Serialize(writer, "Combine");
                    return;
            }
            throw new Exception("Cannot marshal type VerbDescription");
        }

        public static readonly VerbDescriptionConverter Singleton = new VerbDescriptionConverter();
    }

    internal class VerbNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(VerbName) || t == typeof(VerbName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Abandon":
                    return VerbName.Abandon;
                case "Archive":
                    return VerbName.Archive;
                case "Combine":
                    return VerbName.Combine;
                case "Consume":
                    return VerbName.Consume;
                case "Crumble":
                    return VerbName.Crumble;
                case "Delete":
                    return VerbName.Delete;
                case "Destroy":
                    return VerbName.Destroy;
                case "Discard":
                    return VerbName.Discard;
                case "Dismantle":
                    return VerbName.Dismantle;
                case "Insert Key":
                    return VerbName.InsertKey;
                case "Scrap":
                    return VerbName.Scrap;
                case "Store":
                    return VerbName.Store;
                case "Stow":
                    return VerbName.Stow;
                case "Unlock":
                    return VerbName.Unlock;
                case "Use":
                    return VerbName.Use;
            }
            throw new Exception("Cannot unmarshal type VerbName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (VerbName)untypedValue;
            switch (value)
            {
                case VerbName.Abandon:
                    serializer.Serialize(writer, "Abandon");
                    return;
                case VerbName.Archive:
                    serializer.Serialize(writer, "Archive");
                    return;
                case VerbName.Combine:
                    serializer.Serialize(writer, "Combine");
                    return;
                case VerbName.Consume:
                    serializer.Serialize(writer, "Consume");
                    return;
                case VerbName.Crumble:
                    serializer.Serialize(writer, "Crumble");
                    return;
                case VerbName.Delete:
                    serializer.Serialize(writer, "Delete");
                    return;
                case VerbName.Destroy:
                    serializer.Serialize(writer, "Destroy");
                    return;
                case VerbName.Discard:
                    serializer.Serialize(writer, "Discard");
                    return;
                case VerbName.Dismantle:
                    serializer.Serialize(writer, "Dismantle");
                    return;
                case VerbName.InsertKey:
                    serializer.Serialize(writer, "Insert Key");
                    return;
                case VerbName.Scrap:
                    serializer.Serialize(writer, "Scrap");
                    return;
                case VerbName.Store:
                    serializer.Serialize(writer, "Store");
                    return;
                case VerbName.Stow:
                    serializer.Serialize(writer, "Stow");
                    return;
                case VerbName.Unlock:
                    serializer.Serialize(writer, "Unlock");
                    return;
                case VerbName.Use:
                    serializer.Serialize(writer, "Use");
                    return;
            }
            throw new Exception("Cannot marshal type VerbName");
        }

        public static readonly VerbNameConverter Singleton = new VerbNameConverter();
    }

    internal class DisplayStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DisplayString) || t == typeof(DisplayString?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return DisplayString.Empty;
                case "Curse of Osiris":
                    return DisplayString.CurseOfOsiris;
                case "Exclusive Item":
                    return DisplayString.ExclusiveItem;
                case "Preorder Exclusive":
                    return DisplayString.PreorderExclusive;
                case "Requires Annual Pass":
                    return DisplayString.RequiresAnnualPass;
                case "Warmind":
                    return DisplayString.Warmind;
            }
            throw new Exception("Cannot unmarshal type DisplayString");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DisplayString)untypedValue;
            switch (value)
            {
                case DisplayString.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case DisplayString.CurseOfOsiris:
                    serializer.Serialize(writer, "Curse of Osiris");
                    return;
                case DisplayString.ExclusiveItem:
                    serializer.Serialize(writer, "Exclusive Item");
                    return;
                case DisplayString.PreorderExclusive:
                    serializer.Serialize(writer, "Preorder Exclusive");
                    return;
                case DisplayString.RequiresAnnualPass:
                    serializer.Serialize(writer, "Requires Annual Pass");
                    return;
                case DisplayString.Warmind:
                    serializer.Serialize(writer, "Warmind");
                    return;
            }
            throw new Exception("Cannot marshal type DisplayString");
        }

        public static readonly DisplayStringConverter Singleton = new DisplayStringConverter();
    }

    internal class ExpirationTooltipConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ExpirationTooltip) || t == typeof(ExpirationTooltip?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return ExpirationTooltip.Empty;
                case "Expires in .":
                    return ExpirationTooltip.ExpiresIn;
            }
            throw new Exception("Cannot unmarshal type ExpirationTooltip");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ExpirationTooltip)untypedValue;
            switch (value)
            {
                case ExpirationTooltip.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case ExpirationTooltip.ExpiresIn:
                    serializer.Serialize(writer, "Expires in .");
                    return;
            }
            throw new Exception("Cannot marshal type ExpirationTooltip");
        }

        public static readonly ExpirationTooltipConverter Singleton = new ExpirationTooltipConverter();
    }

    internal class ExpiredInOrbitMessageConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ExpiredInOrbitMessage) || t == typeof(ExpiredInOrbitMessage?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return ExpiredInOrbitMessage.Empty;
                case "Expired. Bounty will be removed upon leaving orbit.":
                    return ExpiredInOrbitMessage.ExpiredBountyWillBeRemovedUponLeavingOrbit;
            }
            throw new Exception("Cannot unmarshal type ExpiredInOrbitMessage");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ExpiredInOrbitMessage)untypedValue;
            switch (value)
            {
                case ExpiredInOrbitMessage.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case ExpiredInOrbitMessage.ExpiredBountyWillBeRemovedUponLeavingOrbit:
                    serializer.Serialize(writer, "Expired. Bounty will be removed upon leaving orbit.");
                    return;
            }
            throw new Exception("Cannot marshal type ExpiredInOrbitMessage");
        }

        public static readonly ExpiredInOrbitMessageConverter Singleton = new ExpiredInOrbitMessageConverter();
    }

    internal class TierTypeNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TierTypeName) || t == typeof(TierTypeName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Basic":
                    return TierTypeName.Basic;
                case "Common":
                    return TierTypeName.Common;
                case "Exotic":
                    return TierTypeName.Exotic;
                case "Legendary":
                    return TierTypeName.Legendary;
                case "Rare":
                    return TierTypeName.Rare;
                case "Uncommon":
                    return TierTypeName.Uncommon;
            }
            throw new Exception("Cannot unmarshal type TierTypeName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TierTypeName)untypedValue;
            switch (value)
            {
                case TierTypeName.Basic:
                    serializer.Serialize(writer, "Basic");
                    return;
                case TierTypeName.Common:
                    serializer.Serialize(writer, "Common");
                    return;
                case TierTypeName.Exotic:
                    serializer.Serialize(writer, "Exotic");
                    return;
                case TierTypeName.Legendary:
                    serializer.Serialize(writer, "Legendary");
                    return;
                case TierTypeName.Rare:
                    serializer.Serialize(writer, "Rare");
                    return;
                case TierTypeName.Uncommon:
                    serializer.Serialize(writer, "Uncommon");
                    return;
            }
            throw new Exception("Cannot marshal type TierTypeName");
        }

        public static readonly TierTypeNameConverter Singleton = new TierTypeNameConverter();
    }

    internal class ObjectiveVerbNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ObjectiveVerbName) || t == typeof(ObjectiveVerbName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return ObjectiveVerbName.Empty;
                case "Claim Bounty":
                    return ObjectiveVerbName.ClaimBounty;
                case "Claim Triumph":
                    return ObjectiveVerbName.ClaimTriumph;
                case "Complete":
                    return ObjectiveVerbName.Complete;
            }
            throw new Exception("Cannot unmarshal type ObjectiveVerbName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ObjectiveVerbName)untypedValue;
            switch (value)
            {
                case ObjectiveVerbName.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case ObjectiveVerbName.ClaimBounty:
                    serializer.Serialize(writer, "Claim Bounty");
                    return;
                case ObjectiveVerbName.ClaimTriumph:
                    serializer.Serialize(writer, "Claim Triumph");
                    return;
                case ObjectiveVerbName.Complete:
                    serializer.Serialize(writer, "Complete");
                    return;
            }
            throw new Exception("Cannot marshal type ObjectiveVerbName");
        }

        public static readonly ObjectiveVerbNameConverter Singleton = new ObjectiveVerbNameConverter();
    }

    internal class QuestTypeIdentifierConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(QuestTypeIdentifier) || t == typeof(QuestTypeIdentifier?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return QuestTypeIdentifier.Empty;
                case "black_armory_run":
                    return QuestTypeIdentifier.BlackArmoryRun;
                case "challenge":
                    return QuestTypeIdentifier.Challenge;
                case "patrol":
                    return QuestTypeIdentifier.Patrol;
                case "patrol_tier1":
                    return QuestTypeIdentifier.PatrolTier1;
                case "patrol_tier2":
                    return QuestTypeIdentifier.PatrolTier2;
                case "quest_global":
                    return QuestTypeIdentifier.QuestGlobal;
                case "quest_pvp":
                    return QuestTypeIdentifier.QuestPvp;
                case "quest_story":
                    return QuestTypeIdentifier.QuestStory;
                case "quest_world":
                    return QuestTypeIdentifier.QuestWorld;
                case "treasure_map":
                    return QuestTypeIdentifier.TreasureMap;
            }
            throw new Exception("Cannot unmarshal type QuestTypeIdentifier");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (QuestTypeIdentifier)untypedValue;
            switch (value)
            {
                case QuestTypeIdentifier.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case QuestTypeIdentifier.BlackArmoryRun:
                    serializer.Serialize(writer, "black_armory_run");
                    return;
                case QuestTypeIdentifier.Challenge:
                    serializer.Serialize(writer, "challenge");
                    return;
                case QuestTypeIdentifier.Patrol:
                    serializer.Serialize(writer, "patrol");
                    return;
                case QuestTypeIdentifier.PatrolTier1:
                    serializer.Serialize(writer, "patrol_tier1");
                    return;
                case QuestTypeIdentifier.PatrolTier2:
                    serializer.Serialize(writer, "patrol_tier2");
                    return;
                case QuestTypeIdentifier.QuestGlobal:
                    serializer.Serialize(writer, "quest_global");
                    return;
                case QuestTypeIdentifier.QuestPvp:
                    serializer.Serialize(writer, "quest_pvp");
                    return;
                case QuestTypeIdentifier.QuestStory:
                    serializer.Serialize(writer, "quest_story");
                    return;
                case QuestTypeIdentifier.QuestWorld:
                    serializer.Serialize(writer, "quest_world");
                    return;
                case QuestTypeIdentifier.TreasureMap:
                    serializer.Serialize(writer, "treasure_map");
                    return;
            }
            throw new Exception("Cannot marshal type QuestTypeIdentifier");
        }

        public static readonly QuestTypeIdentifierConverter Singleton = new QuestTypeIdentifierConverter();
    }

    internal class UiPlugLabelConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(UiPlugLabel) || t == typeof(UiPlugLabel?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return UiPlugLabel.Empty;
                case "masterwork":
                    return UiPlugLabel.Masterwork;
                case "masterwork_interactable":
                    return UiPlugLabel.MasterworkInteractable;
            }
            throw new Exception("Cannot unmarshal type UiPlugLabel");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (UiPlugLabel)untypedValue;
            switch (value)
            {
                case UiPlugLabel.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case UiPlugLabel.Masterwork:
                    serializer.Serialize(writer, "masterwork");
                    return;
                case UiPlugLabel.MasterworkInteractable:
                    serializer.Serialize(writer, "masterwork_interactable");
                    return;
            }
            throw new Exception("Cannot marshal type UiPlugLabel");
        }

        public static readonly UiPlugLabelConverter Singleton = new UiPlugLabelConverter();
    }

    internal class PreviewActionStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PreviewActionString) || t == typeof(PreviewActionString?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return PreviewActionString.Empty;
                case "Access":
                    return PreviewActionString.Access;
                case "Configure":
                    return PreviewActionString.Configure;
                case "Details":
                    return PreviewActionString.Details;
                case "Gauntlets":
                    return PreviewActionString.Gauntlets;
                case "Preview":
                    return PreviewActionString.Preview;
            }
            throw new Exception("Cannot unmarshal type PreviewActionString");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PreviewActionString)untypedValue;
            switch (value)
            {
                case PreviewActionString.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case PreviewActionString.Access:
                    serializer.Serialize(writer, "Access");
                    return;
                case PreviewActionString.Configure:
                    serializer.Serialize(writer, "Configure");
                    return;
                case PreviewActionString.Details:
                    serializer.Serialize(writer, "Details");
                    return;
                case PreviewActionString.Gauntlets:
                    serializer.Serialize(writer, "Gauntlets");
                    return;
                case PreviewActionString.Preview:
                    serializer.Serialize(writer, "Preview");
                    return;
            }
            throw new Exception("Cannot marshal type PreviewActionString");
        }

        public static readonly PreviewActionStringConverter Singleton = new PreviewActionStringConverter();
    }

    internal class ScreenStyleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ScreenStyle) || t == typeof(ScreenStyle?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "screen_style_emote":
                    return ScreenStyle.ScreenStyleEmote;
                case "screen_style_mtx_direct_purchase":
                    return ScreenStyle.ScreenStyleMtxDirectPurchase;
                case "screen_style_prismatic_nexus":
                    return ScreenStyle.ScreenStylePrismaticNexus;
                case "screen_style_sockets":
                    return ScreenStyle.ScreenStyleSockets;
                case "screen_style_specializations":
                    return ScreenStyle.ScreenStyleSpecializations;
                case "screen_style_vendor":
                    return ScreenStyle.ScreenStyleVendor;
            }
            throw new Exception("Cannot unmarshal type ScreenStyle");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ScreenStyle)untypedValue;
            switch (value)
            {
                case ScreenStyle.ScreenStyleEmote:
                    serializer.Serialize(writer, "screen_style_emote");
                    return;
                case ScreenStyle.ScreenStyleMtxDirectPurchase:
                    serializer.Serialize(writer, "screen_style_mtx_direct_purchase");
                    return;
                case ScreenStyle.ScreenStylePrismaticNexus:
                    serializer.Serialize(writer, "screen_style_prismatic_nexus");
                    return;
                case ScreenStyle.ScreenStyleSockets:
                    serializer.Serialize(writer, "screen_style_sockets");
                    return;
                case ScreenStyle.ScreenStyleSpecializations:
                    serializer.Serialize(writer, "screen_style_specializations");
                    return;
                case ScreenStyle.ScreenStyleVendor:
                    serializer.Serialize(writer, "screen_style_vendor");
                    return;
            }
            throw new Exception("Cannot marshal type ScreenStyle");
        }

        public static readonly ScreenStyleConverter Singleton = new ScreenStyleConverter();
    }

    internal class OpenActionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(OpenAction) || t == typeof(OpenAction?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return OpenAction.Empty;
                case "Decrypt":
                    return OpenAction.Decrypt;
                case "Open":
                    return OpenAction.Open;
                case "Use":
                    return OpenAction.Use;
            }
            throw new Exception("Cannot unmarshal type OpenAction");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (OpenAction)untypedValue;
            switch (value)
            {
                case OpenAction.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case OpenAction.Decrypt:
                    serializer.Serialize(writer, "Decrypt");
                    return;
                case OpenAction.Open:
                    serializer.Serialize(writer, "Open");
                    return;
                case OpenAction.Use:
                    serializer.Serialize(writer, "Use");
                    return;
            }
            throw new Exception("Cannot marshal type OpenAction");
        }

        public static readonly OpenActionConverter Singleton = new OpenActionConverter();
    }

    internal class DetailConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Detail) || t == typeof(Detail?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return Detail.Empty;
                case "Details":
                    return Detail.Details;
                case "Emotes":
                    return Detail.Emotes;
                case "Eva's Holiday Oven":
                    return Detail.EvaSHolidayOven;
                case "Five of Swords":
                    return Detail.FiveOfSwords;
                case "Nightfall Challenge":
                    return Detail.NightfallChallenge;
                case "Reveler's Tonic":
                    return Detail.RevelerSTonic;
                case "Shader":
                    return Detail.Shader;
                case "Weak Synthesizer":
                    return Detail.WeakSynthesizer;
            }
            throw new Exception("Cannot unmarshal type Detail");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Detail)untypedValue;
            switch (value)
            {
                case Detail.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case Detail.Details:
                    serializer.Serialize(writer, "Details");
                    return;
                case Detail.Emotes:
                    serializer.Serialize(writer, "Emotes");
                    return;
                case Detail.EvaSHolidayOven:
                    serializer.Serialize(writer, "Eva's Holiday Oven");
                    return;
                case Detail.FiveOfSwords:
                    serializer.Serialize(writer, "Five of Swords");
                    return;
                case Detail.NightfallChallenge:
                    serializer.Serialize(writer, "Nightfall Challenge");
                    return;
                case Detail.RevelerSTonic:
                    serializer.Serialize(writer, "Reveler's Tonic");
                    return;
                case Detail.Shader:
                    serializer.Serialize(writer, "Shader");
                    return;
                case Detail.WeakSynthesizer:
                    serializer.Serialize(writer, "Weak Synthesizer");
                    return;
            }
            throw new Exception("Cannot marshal type Detail");
        }

        public static readonly DetailConverter Singleton = new DetailConverter();
    }

    internal class TooltipStyleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TooltipStyle) || t == typeof(TooltipStyle?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "bounty":
                    return TooltipStyle.Bounty;
                case "build":
                    return TooltipStyle.Build;
                case "emblem":
                    return TooltipStyle.Emblem;
                case "package":
                    return TooltipStyle.Package;
                case "quest":
                    return TooltipStyle.Quest;
                case "record":
                    return TooltipStyle.Record;
                case "vendor_action":
                    return TooltipStyle.VendorAction;
            }
            throw new Exception("Cannot unmarshal type TooltipStyle");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TooltipStyle)untypedValue;
            switch (value)
            {
                case TooltipStyle.Bounty:
                    serializer.Serialize(writer, "bounty");
                    return;
                case TooltipStyle.Build:
                    serializer.Serialize(writer, "build");
                    return;
                case TooltipStyle.Emblem:
                    serializer.Serialize(writer, "emblem");
                    return;
                case TooltipStyle.Package:
                    serializer.Serialize(writer, "package");
                    return;
                case TooltipStyle.Quest:
                    serializer.Serialize(writer, "quest");
                    return;
                case TooltipStyle.Record:
                    serializer.Serialize(writer, "record");
                    return;
                case TooltipStyle.VendorAction:
                    serializer.Serialize(writer, "vendor_action");
                    return;
            }
            throw new Exception("Cannot marshal type TooltipStyle");
        }

        public static readonly TooltipStyleConverter Singleton = new TooltipStyleConverter();
    }

    internal class UiItemDisplayStyleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(UiItemDisplayStyle) || t == typeof(UiItemDisplayStyle?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "":
                    return UiItemDisplayStyle.Empty;
                case "ui_display_style_box":
                    return UiItemDisplayStyle.UiDisplayStyleBox;
                case "ui_display_style_engram":
                    return UiItemDisplayStyle.UiDisplayStyleEngram;
                case "ui_display_style_infuse":
                    return UiItemDisplayStyle.UiDisplayStyleInfuse;
                case "ui_display_style_intrinsic_plug":
                    return UiItemDisplayStyle.UiDisplayStyleIntrinsicPlug;
                case "ui_display_style_nexus":
                    return UiItemDisplayStyle.UiDisplayStyleNexus;
                case "ui_display_style_record":
                    return UiItemDisplayStyle.UiDisplayStyleRecord;
                case "ui_display_style_set_container":
                    return UiItemDisplayStyle.UiDisplayStyleSetContainer;
                case "ui_display_style_silver_engram":
                    return UiItemDisplayStyle.UiDisplayStyleSilverEngram;
                case "ui_display_style_token":
                    return UiItemDisplayStyle.UiDisplayStyleToken;
            }
            throw new Exception("Cannot unmarshal type UiItemDisplayStyle");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (UiItemDisplayStyle)untypedValue;
            switch (value)
            {
                case UiItemDisplayStyle.Empty:
                    serializer.Serialize(writer, "");
                    return;
                case UiItemDisplayStyle.UiDisplayStyleBox:
                    serializer.Serialize(writer, "ui_display_style_box");
                    return;
                case UiItemDisplayStyle.UiDisplayStyleEngram:
                    serializer.Serialize(writer, "ui_display_style_engram");
                    return;
                case UiItemDisplayStyle.UiDisplayStyleInfuse:
                    serializer.Serialize(writer, "ui_display_style_infuse");
                    return;
                case UiItemDisplayStyle.UiDisplayStyleIntrinsicPlug:
                    serializer.Serialize(writer, "ui_display_style_intrinsic_plug");
                    return;
                case UiItemDisplayStyle.UiDisplayStyleNexus:
                    serializer.Serialize(writer, "ui_display_style_nexus");
                    return;
                case UiItemDisplayStyle.UiDisplayStyleRecord:
                    serializer.Serialize(writer, "ui_display_style_record");
                    return;
                case UiItemDisplayStyle.UiDisplayStyleSetContainer:
                    serializer.Serialize(writer, "ui_display_style_set_container");
                    return;
                case UiItemDisplayStyle.UiDisplayStyleSilverEngram:
                    serializer.Serialize(writer, "ui_display_style_silver_engram");
                    return;
                case UiItemDisplayStyle.UiDisplayStyleToken:
                    serializer.Serialize(writer, "ui_display_style_token");
                    return;
            }
            throw new Exception("Cannot marshal type UiItemDisplayStyle");
        }

        public static readonly UiItemDisplayStyleConverter Singleton = new UiItemDisplayStyleConverter();
    }
}
